//-------------------------------------------------------------------------
// MemoryAccess_noparam.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL Component MainsMemory Definition
// At /home/varun/PycharmProjects/R-Type/MainMemory.py

module MainsMemory_noparam
(
  input  logic [31:0] address ,
  input  logic [0:0] clk ,
  input  logic [31:0] dataIn ,
  output logic [31:0] dataOut ,
  input  logic [0:0] readEnable ,
  input  logic [0:0] reset ,
  input  logic [3:0] strobe ,
  input  logic [0:0] writeEnable 
);
  localparam logic [2:0] __const__strobeWidth_at_write_logic  = 3'd4;
  logic [31:0] mem [0:255];
  logic [3:0] __tmpvar__write_logic_a;

  // PyMTL Update Block Source
  // At /home/varun/PycharmProjects/R-Type/MainMemory.py:18
  // @update_ff
  // def read_logic():
  //     if (self.readEnable == 1) & (self.writeEnable != 1):
  //         self.dataOut <<= self.mem[self.address[0:8]]
  
  always_ff @(posedge clk) begin : read_logic
    if ( ( readEnable == 1'd1 ) & ( writeEnable != 1'd1 ) ) begin
      dataOut <= mem[address[5'd7:5'd0]];
    end
  end

  // PyMTL Update Block Source
  // At /home/varun/PycharmProjects/R-Type/MainMemory.py:23
  // @update_ff
  // def write_logic():
  //     if (self.readEnable == 1) & (self.writeEnable == 1):
  //         for i in range(strobeWidth):
  //             if self.strobe[i] == 1:
  //                 a = 8 * i
  //                 for j in range(8):
  //                     self.mem[self.address[0:8]][a + j] <<= self.dataIn[a + j]
  
  always_ff @(posedge clk) begin : write_logic
    if ( ( readEnable == 1'd1 ) & ( writeEnable == 1'd1 ) ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__strobeWidth_at_write_logic ); i += 1'd1 )
        if ( strobe[2'(i)] == 1'd1 ) begin
          __tmpvar__write_logic_a = 4'd8 * 4'(i);
          for ( int unsigned j = 1'd0; j < 4'd8; j += 1'd1 )
            mem[address[5'd7:5'd0]][__tmpvar__write_logic_a + 5'(j)] <= dataIn[5'(__tmpvar__write_logic_a) + 5'(j)];
        end
    end
  end

endmodule


// PyMTL Component MemoryAccess Definition
// At /home/varun/PycharmProjects/R-Type/MemoryAccess.py

module MemoryAccess_noparam
(
  input  logic [31:0] branch ,
  input  logic [0:0] clk ,
  output logic [31:0] dataOut ,
  input  logic [0:0] isBranchTaken ,
  input  logic [0:0] isLoadInstruction ,
  input  logic [0:0] isStoreInstruction ,
  input  logic [31:0] jumpAddress ,
  input  logic [31:0] memoryAddress ,
  input  logic [31:0] memoryData ,
  input  logic [0:0] reset ,
  input  logic [31:0] result 
);
  //-------------------------------------------------------------
  // Component MainsMemory
  //-------------------------------------------------------------

  logic [31:0] MainsMemory__address;
  logic [0:0] MainsMemory__clk;
  logic [31:0] MainsMemory__dataIn;
  logic [31:0] MainsMemory__dataOut;
  logic [0:0] MainsMemory__readEnable;
  logic [0:0] MainsMemory__reset;
  logic [3:0] MainsMemory__strobe;
  logic [0:0] MainsMemory__writeEnable;

  MainsMemory_noparam MainsMemory
  (
    .address( MainsMemory__address ),
    .clk( MainsMemory__clk ),
    .dataIn( MainsMemory__dataIn ),
    .dataOut( MainsMemory__dataOut ),
    .readEnable( MainsMemory__readEnable ),
    .reset( MainsMemory__reset ),
    .strobe( MainsMemory__strobe ),
    .writeEnable( MainsMemory__writeEnable )
  );

  //-------------------------------------------------------------
  // End of component MainsMemory
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/varun/PycharmProjects/R-Type/MemoryAccess.py:29
  // @update
  // def assignDataOut():
  //     s.dataOut @= s.MainsMemory.dataOut  # read data, Instruction stored in the instruction memory.
  
  always_comb begin : assignDataOut
    dataOut = MainsMemory__dataOut;
  end

  assign MainsMemory__clk = clk;
  assign MainsMemory__reset = reset;
  assign MainsMemory__writeEnable = 1'd0;
  assign MainsMemory__readEnable = 1'd0;
  assign MainsMemory__address = memoryAddress;
  assign MainsMemory__dataIn = result;

endmodule
